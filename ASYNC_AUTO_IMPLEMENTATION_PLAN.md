# План реализации автоматической асинхронности в D#

## Цель
Сделать так, чтобы D# методы автоматически становились асинхронными при обнаружении вызовов Task-based методов, без необходимости явно писать `async` и `await`.

## Требования
1. **Автоматическое определение**: Если в теле D# метода есть вызов метода, возвращающего `Task`, `Task<T>`, `ValueTask` или `ValueTask<T>`, метод автоматически становится асинхронным
2. **Трансформация возвращаемых типов**:
   - D# `func` → C# `Task` (если есть async внутри)
   - D# `func` → C# `void` (если нет async)
   - D# `int` → C# `Task<int>` (если есть async)
   - D# `int` → C# `int` (если нет async)
3. **Автоматический await**: Все вызовы Task-returning методов получают `await`
4. **Прозрачность**: В D# не нужно писать `async`/`await`

## Этапы реализации

### ✅ 1. Исследование кодовой базы
- [x] Изучить текущий `DSharpSourceGenerator.cs`
- [x] Изучить примеры `.ds` файлов
- [x] Понять текущую логику трансформации

### ⏳ 2. Реализация парсинга и анализа
- [ ] Создать методы для разбора D# кода на методы
- [ ] Определить паттерны для обнаружения Task-based вызовов
- [ ] Реализовать анализ тела метода на наличие async вызовов

### ⏳ 3. Реализация трансформации
- [ ] Реализовать автоматическую вставку `async` в сигнатуру метода
- [ ] Реализовать автоматическую вставку `await` перед Task вызовами
- [ ] Реализовать трансформацию возвращаемых типов (func → Task, T → Task<T>)
- [ ] Обработать edge cases (вложенные методы, lambda expressions)

### ⏳ 4. Тестирование
- [ ] Создать тестовые примеры `.ds` файлов
- [ ] Проверить простой случай: `func` с `Task.Delay`
- [ ] Проверить случай с возвращаемым значением: `int` → `Task<int>`
- [ ] Проверить цепочки вызовов (метод A вызывает async метод B)
- [ ] Проверить смешанный код (sync + async вызовы)

### ⏳ 5. Обновление документации
- [ ] Обновить `COMPARISON.md` с новыми примерами
- [ ] Добавить примеры автоматической асинхронности

### ⏳ 6. Финальная проверка
- [ ] Запустить `dotnet build`
- [ ] Проверить сгенерированный код
- [ ] Убедиться, что проект компилируется

## Технические детали

### Паттерны для обнаружения async вызовов
Нужно искать в теле метода:
- `Task.` (Task.Delay, Task.Run, Task.WhenAll, etc.)
- `Task<` (возвращаемые типы)
- `ValueTask`
- `.Task` (properties)
- Вызовы методов, которые сами являются async в D#

### Алгоритм трансформации
1. Разбить код на методы (по сигнатурам)
2. Для каждого метода:
   - Проанализировать тело на наличие Task вызовов
   - Если найдены:
     - Добавить `async` в сигнатуру
     - Добавить `await` перед каждым Task вызовом
     - Трансформировать возвращаемый тип
   - Если не найдены:
     - Оставить как есть (func → void)

### Edge cases
- Lambda expressions: `() => Task.Delay(100)` - не должны влиять на внешний метод
- Вложенные методы: локальные функции должны обрабатываться независимо
- Комментарии: не искать Task в комментариях
- Строки: не искать Task в string literals

## Примечания
- Начнём с простой regex-based реализации
- В будущем можно перейти на Roslyn Syntax Tree для более точного анализа

