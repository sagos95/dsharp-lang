using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace DSharp.Generator;

[Generator]
public class DSharpSourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Get all .ds files
        var dsFiles = context.AdditionalTextsProvider
            .Where(file => file.Path.EndsWith(".ds"));

        // Transform each .ds file to generated C# code
        var generatedSources = dsFiles.Select((file, cancellationToken) =>
        {
            var sourceText = file.GetText(cancellationToken);
            if (sourceText == null)
                return (string.Empty, string.Empty);

            var dsContent = sourceText.ToString();
            var csharpCode = TranslateDSharpToCSharp(dsContent);

            var fileName = System.IO.Path.GetFileNameWithoutExtension(file.Path);
            var generatedFileName = $"{fileName}.g.cs";

            return (generatedFileName, csharpCode);
        });

        // Register generated sources
        context.RegisterSourceOutput(generatedSources, (spc, source) =>
        {
            if (!string.IsNullOrEmpty(source.Item1) && !string.IsNullOrEmpty(source.Item2))
            {
                spc.AddSource(source.Item1, SourceText.From(source.Item2, Encoding.UTF8));
            }
        });
    }

    private static string TranslateDSharpToCSharp(string dsCode)
    {
        // Process methods with automatic async detection
        var csharpCode = ProcessMethodsWithAutoAsync(dsCode);
        
        // Ensure file has proper structure
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        
        // Check if the code already has namespace declaration
        if (!csharpCode.Contains("namespace "))
        {
            sb.AppendLine("namespace DSharp.Sandbox.Generated;");
            sb.AppendLine();
        }
        
        sb.Append(csharpCode);
        
        return sb.ToString();
    }

    private static string ProcessMethodsWithAutoAsync(string dsCode)
    {
        var lines = dsCode.Split('\n');
        var result = new StringBuilder();
        
        int i = 0;
        while (i < lines.Length)
        {
            var line = lines[i];
            
            // Check if this line contains a method declaration
            var methodMatch = Regex.Match(line, @"^\s*(?<modifiers>(?:public|private|protected|internal|static|virtual|override|abstract|\s)+)\s+(?<returnType>func|async\s+func|[\w<>[\],]+)\s+(?<methodName>\w+)\s*\((?<parameters>[^)]*)\)\s*$");
            
            if (methodMatch.Success && i + 1 < lines.Length && lines[i + 1].TrimStart().StartsWith("{"))
            {
                // Found a method declaration
                var modifiers = methodMatch.Groups["modifiers"].Value.Trim();
                var returnType = methodMatch.Groups["returnType"].Value.Trim();
                var methodName = methodMatch.Groups["methodName"].Value;
                var parameters = methodMatch.Groups["parameters"].Value;
                
                // Extract method body
                int bodyStart = i + 1;
                var methodBody = ExtractMethodBodyFromLines(lines, bodyStart);
                
                if (methodBody != null)
                {
                    // Check if already has async
                    if (returnType.Contains("async"))
                    {
                        // Replace "async func" with "async Task"
                        returnType = returnType.Replace("async func", "async Task").Replace("async  func", "async Task");
                        result.Append($"    {modifiers} {returnType} {methodName}({parameters})");
                        result.AppendLine();
                        result.Append(methodBody);
                        
                        i = bodyStart + CountLines(methodBody);
                        continue;
                    }
                    
                    // Check if needs to be async
                    bool needsAsync = ContainsTaskCalls(methodBody);
                    
                    if (needsAsync)
                    {
                        // Make method async
                        string asyncReturnType;
                        if (returnType == "func")
                            asyncReturnType = "Task";
                        else if (returnType == "void")
                            asyncReturnType = "Task";
                        else
                            asyncReturnType = $"Task<{returnType}>";
                        
                        // Add await to Task calls
                        var asyncBody = AddAwaitToTaskCalls(methodBody);
                        
                        result.Append($"    {modifiers} async {asyncReturnType} {methodName}({parameters})");
                        result.AppendLine();
                        result.Append(asyncBody);
                        
                        i = bodyStart + CountLines(methodBody);
                        continue;
                    }
                    else
                    {
                        // Regular method - just replace func with void
                        if (returnType == "func")
                            returnType = "void";
                        
                        result.Append($"    {modifiers} {returnType} {methodName}({parameters})");
                        result.AppendLine();
                        result.Append(methodBody);
                        
                        i = bodyStart + CountLines(methodBody);
                        continue;
                    }
                }
            }
            
            // Not a method or couldn't process - keep line as is
            result.AppendLine(line);
            i++;
        }
        
        return result.ToString();
    }

    private static string? ExtractMethodBodyFromLines(string[] lines, int startIndex)
    {
        if (startIndex >= lines.Length || !lines[startIndex].TrimStart().StartsWith("{"))
            return null;
        
        var sb = new StringBuilder();
        int braceCount = 0;
        int i = startIndex;
        
        while (i < lines.Length)
        {
            var line = lines[i];
            sb.AppendLine(line);
            
            foreach (var ch in line)
            {
                if (ch == '{') braceCount++;
                else if (ch == '}') braceCount--;
            }
            
            if (braceCount == 0)
            {
                return sb.ToString();
            }
            
            i++;
        }
        
        return null;
    }

    private static int CountLines(string text)
    {
        if (string.IsNullOrEmpty(text))
            return 0;
        
        return text.Split('\n').Length - 1;
    }


    private static bool ContainsTaskCalls(string methodBody)
    {
        // Remove strings to avoid false positives
        var bodyWithoutStrings = Regex.Replace(methodBody, @"""([^""\\]|\\.)*""", "");
        
        // Remove comments to avoid false positives
        bodyWithoutStrings = Regex.Replace(bodyWithoutStrings, @"//.*$", "", RegexOptions.Multiline);
        bodyWithoutStrings = Regex.Replace(bodyWithoutStrings, @"/\*.*?\*/", "", RegexOptions.Singleline);
        
        // Remove Run.Async calls - they should not make the method async
        // This regex handles nested parentheses by matching Run.Async with lambda expressions
        bodyWithoutStrings = Regex.Replace(bodyWithoutStrings, @"Run\.Async\s*\([^;]+?\);", "", RegexOptions.Singleline);
        
        // Patterns that indicate Task-based async operations
        var taskPatterns = new[]
        {
            @"\bTask\s*\.",           // Task.Delay, Task.Run, etc.
            @"\bTask<",               // Task<T>
            @"\bValueTask\s*\.",      // ValueTask.
            @"\bValueTask<",          // ValueTask<T>
            @"\.ConfigureAwait\(",    // .ConfigureAwait
            @"\bTask\s+\w+\s*=",      // var task = ...
            @"\bTask<\w+>\s+\w+\s*=", // Task<int> result = ...
        };
        
        if (taskPatterns.Any(pattern => Regex.IsMatch(bodyWithoutStrings, pattern)))
            return true;
        
        // Also check for method calls that look async (heuristic)
        // Methods starting with capital letter that contain async patterns
        var asyncMethodPatterns = new[]
        {
            @"\b[A-Z]\w*Async\w*\s*\(",      // MethodAsync()
            @"\bDelayed\w+\s*\(",              // DelayedPrint()
            @"\bGet\w+Async\s*\(",             // GetDataAsync()
            @"\bFetch\w+\s*\(",                // FetchData()
            @"\bLoad\w+\s*\(",                 // LoadData()
            @"\bSave\w+\s*\(",                 // SaveData()
            @"\bSend\w+\s*\(",                 // SendMessage()
            @"\bProcess\w+\s*\(",              // ProcessData()
        };
        
        return asyncMethodPatterns.Any(pattern => Regex.IsMatch(bodyWithoutStrings, pattern));
    }


    private static string AddAwaitToTaskCalls(string body)
    {
        var result = body;
        
        // Skip Run.Async calls - they should run without await
        // (already handled, no changes needed)
        
        // First pass: handle assignments with Task-returning calls
        // Pattern: var x = Task.Run(...) - can be multiline
        result = Regex.Replace(result,
            @"(\b(?:var|[\w<>]+)\s+\w+\s*=\s*)(Task\.Run\s*\([^;]+?\);)",
            "$1await $2",
            RegexOptions.Singleline);
        
        // Pattern: var x = Task.Delay(...) - single line
        result = Regex.Replace(result,
            @"(\b(?:var|[\w<>]+)\s+\w+\s*=\s*)(?<!await\s+)(Task\.Delay\s*\([^)]*\)\s*;)",
            "$1await $2");
        
        // Second pass: handle statement calls (not assignments)
        var lines = result.Split('\n');
        var sb = new StringBuilder();
        
        foreach (var line in lines)
        {
            var trimmedLine = line.TrimStart();
            
            // Skip Run.Async calls
            if (trimmedLine.Contains("Run.Async("))
            {
                sb.AppendLine(line);
                continue;
            }
            
            var processedLine = line;
            
            // Task.Method(...); - single line calls
            if (Regex.IsMatch(trimmedLine, @"^\s*Task\.\w+\([^)]*\);\s*$"))
            {
                processedLine = Regex.Replace(processedLine,
                    @"^(\s*)(?<!await\s+)(Task\.\w+\([^)]*\);)$",
                    "$1await $2");
            }
            // ValueTask.Method(...);
            else if (Regex.IsMatch(trimmedLine, @"^\s*ValueTask\.\w+\([^)]*\);\s*$"))
            {
                processedLine = Regex.Replace(processedLine,
                    @"^(\s*)(?<!await\s+)(ValueTask\.\w+\([^)]*\);)$",
                    "$1await $2");
            }
            // Method calls that look async (but not Task.* calls)
            else if (Regex.IsMatch(trimmedLine, @"^\s*[A-Z]\w+\([^)]*\);\s*$") && !trimmedLine.Contains("Task."))
            {
                var match = Regex.Match(trimmedLine, @"[A-Z]\w+");
                if (match.Success)
                {
                    var methodName = match.Value;
                    // Check if it looks like an async method
                    if (methodName.Contains("Async") ||
                        methodName.StartsWith("Delayed") ||
                        methodName.StartsWith("Get") ||
                        methodName.StartsWith("Fetch") ||
                        methodName.StartsWith("Load") ||
                        methodName.StartsWith("Save") ||
                        methodName.StartsWith("Send") ||
                        methodName.StartsWith("Process"))
                    {
                        processedLine = Regex.Replace(processedLine,
                            @"^(\s*)(?<!await\s+)([A-Z]\w+\([^)]*\);)$",
                            "$1await $2");
                    }
                }
            }
            
            sb.AppendLine(processedLine);
        }
        
        return sb.ToString();
    }
}

